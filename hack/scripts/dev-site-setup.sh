#!/usr/bin/env bash
# Creates a site (idempotent), waits for the kubeconfig secret to be
# provisioned by the RBAC controller, extracts it, and writes .env so
# that `make run-agent` can pick it up.
#
# Usage:
#   hack/scripts/dev-site-setup.sh <site-name> [labels]
#
# Requires:
#   - kedge CLI built in $BINDIR (default: bin/)
#   - kubectl configured to reach the tenant workspace (run `make dev-login` first)

set -euo pipefail

SITE_NAME="${1:?Usage: $0 <site-name> [labels]}"
LABELS="${2:-env=dev,provider=local}"

BINDIR="${BINDIR:-bin}"
NAMESPACE="kedge-system"
SECRET_NAME="site-${SITE_NAME}-kubeconfig"
OUTPUT_FILE=".site-kubeconfig"
TIMEOUT=120

# 1. Create site (ignore AlreadyExists).
echo "Creating site ${SITE_NAME}..."
PATH="${BINDIR}:${PATH}" "${BINDIR}/kedge" site create "${SITE_NAME}" \
  --labels "${LABELS}" 2>/dev/null || true

# 2. Wait for kubeconfig secret.
echo "Waiting for secret ${NAMESPACE}/${SECRET_NAME}..."
elapsed=0
while true; do
  if kubectl get secret -n "${NAMESPACE}" "${SECRET_NAME}" &>/dev/null; then
    break
  fi
  if [ "${elapsed}" -ge "${TIMEOUT}" ]; then
    echo "ERROR: Timed out after ${TIMEOUT}s waiting for secret ${SECRET_NAME}" >&2
    exit 1
  fi
  sleep 2
  elapsed=$((elapsed + 2))
  printf "  waiting... (%ds)\r" "${elapsed}"
done
echo ""

# 3. Extract kubeconfig from secret.
echo "Extracting kubeconfig to ${OUTPUT_FILE}..."
kubectl get secret -n "${NAMESPACE}" "${SECRET_NAME}" \
  -o jsonpath='{.data.kubeconfig}' | base64 -d > "${OUTPUT_FILE}"

# 4. Write .env for make run-agent.
cat > .env <<EOF
# Generated by hack/scripts/dev-site-setup.sh â€” do not commit
KEDGE_SITE_NAME=${SITE_NAME}
KEDGE_LABELS=${LABELS}
KEDGE_SITE_KUBECONFIG=${OUTPUT_FILE}
EOF

echo "Done!"
echo "  Site kubeconfig: ${OUTPUT_FILE}"
echo "  .env updated"
echo "  Run 'make dev-run-agent' to start the agent"
